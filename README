EMRPC is a EventMachine-based remote procedure call library.
It looks like DRb, but is much more efficient and provides
asynchronous erlang-like interface along with blocking synchronous interface. 

Author: Oleg Andreev <oleganza@gmail.com>

Many thanks to:
* linkfeed.ru for the real-world EMRPC-based application.
* pierlis.com for the table/chair/wifi in Paris.


EXAMPLES

You may try out examples using bin/em_console IRB session.
Just open the console and paste the code.

-------------------------------------------------------------------------------

HELLO WORLD (BLOCKING API)

  class HelloWorld
    def action
      "Hello!"
    end
  end
    
  server = EMRPC::Server.new(:address => 'emrpc://localhost:4000/', 
                             :backend => HelloWorld.new)
  emt = Thread.new do 
    EM::run do
      server.start
    end
  end
  sleep 0.2
  client = EMRPC::Client.new('emrpc://localhost:4000/')
  client.action == "Hello!" #=> true

-------------------------------------------------------------------------------

HELLO WORLD (EVENTED API)

  class HelloWorld
    include Pid
    def action(sender)
      puts "HelloWorld replies to the sender #{sender}..."
      sender.reply(self, "Hello!")
    end
  end

  class User
    include Pid
    def connected(pid)
      puts "Pid #{pid} connected with the user."
      pid.action(self)
    end
    def reply(pid, msg)
      puts "Pid #{pid} replied: #{msg}"
    end
  end
    
  EM::run do
    hw = HelloWorld.new
    hw.bind('emrpc://localhost:4000/')  # bind a pid to the address 
    
    oleg = User.new
    oleg.connect('emrpc://localhost:4000/') # connect to that address
  end
  
  # Output:
  Pid #<EMRPC::RemotePid:0x143b740> connected with the user.
  HelloWorld replies to the sender #<User:0x143b4d4>...
  Pid #<HelloWorld:0x143d540> replied: Hello!

-------------------------------------------------------------------------------

HELLO WORLD (EVENTED WRAPPER, MIXED API)

  # in first process:
  class HelloWorld
    def action
      "Hello!"
    end
  end
  
  server = EMRPC::Server.new(:address => 'emrpc://localhost:4000/', 
                             :backend => HelloWorld.new)
  
  EM::run do
    server.start
  end
  
  # in the other process (actually, this works in the same process with the server too):
  class User
    include Pid
    def connected(pid)
      puts "Pid #{pid} connected to the user."
      pid.send(self, :action)
    end
    def on_return(pid, msg)
      puts "Pid #{pid} replied: #{msg}"
    end
  end
  
  EM::run do
    oleg = User.new
    oleg.connect('emrpc://localhost:4000/') # connect to that address
  end

  # Output:
  Pid #<EMRPC::RemotePid:0x143b740> connected to the user.
  Pid #<HelloWorld:0x143d540> replied: Hello!

-------------------------------------------------------------------------------

